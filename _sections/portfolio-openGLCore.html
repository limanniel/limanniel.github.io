---
title: OpenGL-Core Application
icon: fa-chevron-right
order: 5
---

<h1>OpenGL rendering application, that allows .obj models to be loaded in, accompanied with .bmp texture loading for the models. Allows user to freely move around the scene or move the tank, depending on which camera mode you are using (free camera, camera from behind the tank). Application has been written by using OpenGL's core-profile therefore allowing programmable pipeline approach opposed to fixed-pipeline, which gives much more flexibility as allows Shaders to be written for each segment of the graphics pipeline (vertex, pixel, tessellation etc...). Application utilises GLEW library to create bindings for OpenGL with drivers to provide most recent supported version, as well as GLM Library for maths related structures such as Matrices so that they're memory aligned, and lastly FreeGLUT library for means of easily creating and managing windows.</h1>

</br>
<div class="12u 12u$(mobile)">
    <a class="image fit"></a><img src="assets/images/showcase-opengl.gif" alt="OpenGL-Core Application Showcase" /></a>
</div>

<a href="https://github.com/limanniel/CronusGL">GitHub Repository</a>

<h1>
    Application being essentially first touch in writing Graphics Application using straight OpenGL code, was definitely not an easy journey but extremely rewarding in the end as I got to learn so many new things and concepts. Starting with understanding concepts of all graphics pipeline stages that happen during runtime, understanding and using various matrices such as world, view or projection. Learning plenty of new data structures like linked lists, binary trees and scene graphs. Ending on writing parsers to be able to load in .obj models and .bmp textures.
</h1>
</br>
<h1>Application comes with custom
    <ul>
        <li>.OBJ Model Loader</li>
        <li>.BMP Texture Loader</li>
        <li>Phong Lighting Shader</li>
        <li>Scene Graph</li>
        <li>Linked List Data Structure</li>
        <li>Camera Class</li>
    </ul>
</h1>
</br>
<h1>Most noticeable difficulty gave me writing parsers, and in particular .bmp parser. This would be because of it being really strict on reading correctly and assigning data from header of the .bmp image to local variables within my c++ code, where all of the variables needed to be correct to the very byte size expected from .bmp specification as otherwise read data wouldn't be fitted in according variables resulting in corrupted image. Another matter being that by default c++ compiler creates padding around variables for the safety, but that needed to be changed in case of reading .bmp file as memory would get mis-aligned.
</h1>
<pre><code>#pragma pack(push, 1)</code></pre>
<h1>I've managed to achieve that by using pre-processor directive to remove the padding whilst reading the image file. All together it taken a lot of time to research and understand why things were not working the way they were supposed to regardless code being correct.</h1>
